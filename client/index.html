<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebRTC Cloud Gaming Client</title>
  <style>
    body { background:#000; color:#0f0; font-family:monospace; text-align:center }
    canvas { max-width:90vw; max-height:80vh; display:block; margin:10px auto; background:#111; cursor:none }
    pre { white-space:pre-wrap; background:#111; color:#0f0; padding:8px; text-align:left; max-width:90vw; margin:10px auto }
  </style>
</head>
<body>
  <h1>ðŸŽ® Orbit Game Client</h1>
  <div id="statsBar" style="color:#0ff; margin:8px; font-weight:bold"></div>
  <canvas id="gameCanvas"></canvas>
  <audio id="remoteAudio" autoplay></audio>
  <pre id="log"></pre>

  <script>
  const logEl = document.getElementById('log');
  const log = (...args)=>{ const s=args.join(' '); console.log(s);  };

  let pc, channel, video;

  async function start(){
    pc = new RTCPeerConnection({
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    });

    pc.onicegatheringstatechange = ()=> log("gathering:", pc.iceGatheringState);
    pc.oniceconnectionstatechange = ()=> log("ice:", pc.iceConnectionState);
    pc.onconnectionstatechange = ()=> log("pc:", pc.connectionState);

   pc.addTransceiver("video", { direction:"recvonly" });
pc.addTransceiver("audio", { direction:"recvonly" });

    // Ù…Ù†Ø¨Ø¹ ÙˆÛŒØ¯ÛŒÙˆ (Ù¾Ù†Ù‡Ø§Ù†)
    video = document.createElement("video");
    video.autoplay = true;
    video.playsInline = true;
    video.muted = true; // Ù„Ø§Ø²Ù… Ø¨Ø±Ø§ÛŒ autoplay
    // Ù…Ø®ÙÛŒ Ø¨Ø¯ÙˆÙ† throttle
    video.style.position = "absolute";
    video.style.left = "-9999px";
    video.style.opacity = "0";
    video.style.width = "1px";
    video.style.height = "1px";
    video.style.pointerEvents = "none";
    document.body.appendChild(video);

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
		canvas.tabIndex = 0;       // Ù…Ù‡Ù…: Ø¨Ø¯ÙˆÙ† Ø§ÛŒÙ†ØŒ preventDefault Ø¨Ø±Ø§ÛŒ Tab Ù‡Ù…ÛŒØ´Ù‡ Ú©Ø§Ø± Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯
    canvas.focus();
pc.ontrack = (ev) => {
    log("ontrack:", ev.track.kind, "streams:", ev.streams.length);
    if (ev.track.kind === "video") {
        video.srcObject = ev.streams[0];
        video.play().catch(e => log("video.play err:", e));
        log("Video track received, width:", video.videoWidth, "height:", video.videoHeight);

        // ðŸŽ¬ Ø±Ø³Ù… Ø¨Ø§ requestVideoFrameCallback (Ø³ÛŒÙ†Ú© Ø¯Ù‚ÛŒÙ‚ Ø¨Ø§ ÙØ±ÛŒÙ…â€ŒÙ‡Ø§)
        function pump(now, metadata) {
          if (video.videoWidth > 0) {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          }
          video.requestVideoFrameCallback(pump);
        }
        video.requestVideoFrameCallback(pump);;
    }
    if (ev.track.kind === "audio") {
        const audioEl = document.getElementById("remoteAudio");
        audioEl.srcObject = ev.streams[0];
    }
};
    // DataChannel Ø¨Ø±Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ
    channel = pc.createDataChannel("input");

    channel.onopen = ()=> {
      log("âœ… DataChannel opened for input");
      enableInputEvents(canvas);
	   canvas.focus();   
    };
    channel.onclose = ()=> log("âŒ DataChannel closed");
    // Offer â†’ Ø³Ø±ÙˆØ±
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    log("local offer set. SDP len:", offer.sdp.length);

    const res = await fetch('/offer', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({sdp: offer.sdp, type: offer.type})
    });
    const answer = await res.json();
    await pc.setRemoteDescription(answer);
    log("remote answer set. SDP len:", answer.sdp.length);



 // ðŸ“Š Ø¢Ù…Ø§Ø±
    let lastBytesReceived = 0, lastBytesSent = 0, lastTime = Date.now();
    let fpsNow = 0, kbpsDownNow = 0, kbpsUpNow = 0, rttNow = 0;

   setInterval(async ()=>{
      const now = Date.now();
      const stats = await pc.getStats();
      stats.forEach(report=>{
        if (report.type === "inbound-rtp" && report.kind === "video") {
          const deltaTime = (now - lastTime) / 1000;
          const deltaBytes = report.bytesReceived - lastBytesReceived;
          kbpsDownNow = (deltaBytes * 8 / 1000 / deltaTime).toFixed(1);
          fpsNow = report.framesPerSecond || 0;
          lastBytesReceived = report.bytesReceived;
        }
        if (report.type === "outbound-rtp") {
          const deltaTime = (now - lastTime) / 1000;
          const deltaBytes = report.bytesSent - lastBytesSent;
          kbpsUpNow = (deltaBytes * 8 / 1000 / deltaTime).toFixed(1);
          lastBytesSent = report.bytesSent;
        }
        if (report.type === "candidate-pair" && report.state === "succeeded" && report.currentRoundTripTime) {
          rttNow = (report.currentRoundTripTime * 1000).toFixed(1);
        }
      });
      lastTime = now;
      document.getElementById("statsBar").innerText =
        `FPS: ${fpsNow} | â¬‡ï¸ ${kbpsDownNow} kbps | â¬†ï¸ ${kbpsUpNow} kbps | Ping: ${rttNow} ms`;
    }, 2000);
  }


  function enableInputEvents(canvas){
    // Pointer Lock Ø±ÙˆÛŒ canvas

    canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
    canvas.addEventListener("click", ()=>{
      canvas.requestPointerLock();
	   canvas.focus();
    });
    const blockDefaultKeys = new Set([
      "Tab","AltLeft","AltRight","MetaLeft","MetaRight",
      "F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12"
    ]);
    // Ú©ÛŒØ¨ÙˆØ±Ø¯
    document.addEventListener("keydown", e=>{
	 if (blockDefaultKeys.has(e.code)) e.preventDefault();
      if(channel.readyState==="open")
        channel.send(JSON.stringify({type:"keydown", key:e.code}));
    });
    document.addEventListener("keyup", e=>{
	 if (blockDefaultKeys.has(e.code)) e.preventDefault();
      if(channel.readyState==="open")
        channel.send(JSON.stringify({type:"keyup", key:e.code}));
    });

    // Ù…ÙˆØ³ (relative ÙÙ‚Ø· ÙˆÙ‚ØªÛŒ lock ÙØ¹Ø§Ù„Ù‡)
    document.addEventListener("mousemove", e=>{
      if (document.pointerLockElement === canvas && channel.readyState==="open") {
        channel.send(JSON.stringify({type:"mousemove", x:e.movementX, y:e.movementY}));
      }
    });
    document.addEventListener("mousedown", e=>{
      if(channel.readyState==="open")
        channel.send(JSON.stringify({type:"mousedown", button:e.button}));
    });
    document.addEventListener("mouseup", e=>{
      if(channel.readyState==="open")
        channel.send(JSON.stringify({type:"mouseup", button:e.button}));
    });
    document.addEventListener("wheel", e=>{
      if(channel.readyState==="open")
        channel.send(JSON.stringify({type:"wheel", delta:e.deltaY}));
    });
	 window.addEventListener("blur", ()=> canvas.focus());
    document.addEventListener("visibilitychange", ()=>{
      if (document.visibilityState === "visible") canvas.focus();
    });
  }

  start();
  </script>
</body>
</html>
