<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <link rel="manifest" href="/client/manifest.json">
<meta name="theme-color" content="#000000">
  <title>WebRTC Cloud Gaming Client</title>
  <style>
    body {
      margin:0; background:#000; color:#0f0; font-family:monospace;
      overflow:hidden;
    }
    #statsBar {
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      padding: 6px 10px;
      background: rgba(0,0,0,0.6);
      color: #0ff;
      font-weight: bold;
      font-size: 14px;
      text-align: left;
      z-index: 10000;
    }
    #videoContainer {
      width:100%; height:100%;
      background:#000;
    }
    #gameVideo {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background:#000;
      display:block;
      cursor:none;
    }
    #exitOverlay {
      position:fixed;
      top:0; left:0;
      width:100%; height:30px;
      background:rgba(0,0,0,0.7);
      color:#fff; font-family:monospace;
      text-align:center; line-height:30px;
      display:none; z-index:99999;
    }
    pre { display:none }
  </style>
</head>
<body>
  <div id="statsBar">Loading...</div>
  <div id="videoContainer">
    <video id="gameVideo" autoplay playsinline muted></video>
  </div>
  <audio id="remoteAudio" autoplay></audio>
  <div id="exitOverlay">â³ Ø¨Ø±Ø§ÛŒ Ø®Ø±ÙˆØ¬ ESC Ø±Ø§ Ù†Ú¯Ù‡ Ø¯Ø§Ø±ÛŒØ¯...</div>
  <pre id="log"></pre>

  <script>
  const logEl = document.getElementById('log');
  const log = (...args)=>{ const s=args.join(' '); console.log(s); logEl.textContent += s+"\\n"; };

  let pc, channel;
  const video = document.getElementById("gameVideo");
  <!-- video.playbackRate = 1.0; -->
<!-- video.delay = 0; -->
  const container = document.getElementById("videoContainer");
  const overlay = document.getElementById("exitOverlay");

  async function start(){
    pc = new RTCPeerConnection({
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    });

    pc.addTransceiver("video", {
		  direction: "recvonly",
		  sendEncodings: [
			{ maxBitrate: 9000000 }  // 6 Mbps
		  ]
		});
    pc.addTransceiver("audio", { direction:"recvonly" });

    pc.ontrack = (ev) => {
      if (ev.track.kind === "video") {
        video.srcObject = ev.streams[0];
        video.play().catch(e => log("video.play err:", e));
      }
      if (ev.track.kind === "audio") {
        document.getElementById("remoteAudio").srcObject = ev.streams[0];
      }
    };

    channel = pc.createDataChannel("input");
    channel.onopen = ()=> {
      log("âœ… DataChannel opened for input");
      enableInputEvents(video);
      video.focus();
    };
    channel.onclose = ()=> log("âŒ DataChannel closed");

    // Offer â†’ Ø³Ø±ÙˆØ±
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    const res = await fetch('/offer', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({sdp: offer.sdp, type: offer.type})
    });
    const answer = await res.json();
    await pc.setRemoteDescription(answer);
pc.getSenders().forEach(s=>{
  if(s.track && s.track.kind==="video"){
    let params = s.getParameters();
    if (!params.degradationPreference) {
      params.degradationPreference = "maintain-framerate";
    }
    s.setParameters(params);
  }
});
    // ğŸ“Š Ø¢Ù…Ø§Ø±
    let lastBytesReceived = 0, lastBytesSent = 0, lastTime = Date.now();
    let fpsNow = 0, kbpsDownNow = 0, kbpsUpNow = 0, rttNow = 0;
    setInterval(async ()=>{
      const now = Date.now();
      const stats = await pc.getStats();
      stats.forEach(report=>{
        if (report.type === "inbound-rtp" && report.kind === "video") {
          const deltaTime = (now - lastTime) / 1000;
          const deltaBytes = report.bytesReceived - lastBytesReceived;
          kbpsDownNow = (deltaBytes * 8 / 1000 / deltaTime).toFixed(1);
          fpsNow = report.framesPerSecond || 0;
          lastBytesReceived = report.bytesReceived;
        }
        if (report.type === "outbound-rtp") {
          const deltaTime = (now - lastTime) / 1000;
          const deltaBytes = report.bytesSent - lastBytesSent;
          kbpsUpNow = (deltaBytes * 8 / 1000 / deltaTime).toFixed(1);
          lastBytesSent = report.bytesSent;
        }
        if (report.type === "candidate-pair" && report.state === "succeeded" && report.currentRoundTripTime) {
          rttNow = (report.currentRoundTripTime * 1000).toFixed(1);
        }
      });
      lastTime = now;
      document.getElementById("statsBar").innerText =
        `FPS: ${fpsNow} | â¬‡ï¸ ${kbpsDownNow} kbps | â¬†ï¸ ${kbpsUpNow} kbps | Ping: ${rttNow} ms`;
    }, 2000);
  }

  // ğŸ® ÙˆØ±ÙˆØ¯ÛŒ Ù…ÙˆØ³/Ú©ÛŒØ¨ÙˆØ±Ø¯
  function enableInputEvents(video){
    video.requestPointerLock = video.requestPointerLock || video.mozRequestPointerLock;
    video.addEventListener("click", ()=>{
      video.requestPointerLock();
      video.focus();
    });

    const blockDefaultKeys = new Set([
      "Tab","AltLeft","AltRight","MetaLeft","MetaRight",
      "F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12"
    ]);

    document.addEventListener("keydown", e=>{
      if (blockDefaultKeys.has(e.code)) e.preventDefault();
      if(channel.readyState==="open")
        channel.send(JSON.stringify({type:"keydown", key:e.code}));
    });
    document.addEventListener("keyup", e=>{
      if (blockDefaultKeys.has(e.code)) e.preventDefault();
      if(channel.readyState==="open")
        channel.send(JSON.stringify({type:"keyup", key:e.code}));
    });

    document.addEventListener("mousemove", e=>{
      if (document.pointerLockElement === video && channel.readyState==="open") {
        channel.send(JSON.stringify({type:"mousemove", x:e.movementX, y:e.movementY}));
      }
    });
    document.addEventListener("mousedown", e=>{
      if(channel.readyState==="open")
        channel.send(JSON.stringify({type:"mousedown", button:e.button}));
    });
    document.addEventListener("mouseup", e=>{
      if(channel.readyState==="open")
        channel.send(JSON.stringify({type:"mouseup", button:e.button}));
    });
    document.addEventListener("wheel", e=>{
      if(channel.readyState==="open")
        channel.send(JSON.stringify({type:"wheel", delta:e.deltaY}));
    });
  }

// ğŸ¬ ÙÙˆÙ„â€ŒØ§Ø³Ú©Ø±ÛŒÙ† Ø¨Ø§ ESC Ù†Ú¯Ù‡â€ŒØ¯Ø§Ø´ØªÙ†ÛŒ
function enableFullscreen(){
  async function goFullscreen(){
    if (!document.fullscreenElement){
      <!-- await container.requestFullscreen(); -->
      video.focus();
  console.log('keyboard' in navigator , 'lock' in navigator.keyboard);
      // ğŸ”‘ Ø¨Ø¹Ø¯ Ø§Ø² ÙˆØ±ÙˆØ¯ Ø¨Ù‡ fullscreenØŒ ESC Ø±Ùˆ Ù‚ÙÙ„ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
      if ('keyboard' in navigator && 'lock' in navigator.keyboard) {
	  console.log("444");
        try {
          await navigator.keyboard.lock(['Escape']);
          console.log("âœ… ESC locked with Keyboard Lock API");
        } catch(e) {
          console.warn("Keyboard lock failed:", e);
        }
      }
    }
  }
  container.addEventListener("click", goFullscreen);

  // Ù¾ÛŒØ§Ù… ÙˆÙ‚ØªÛŒ ESC Ú©ÙˆØªØ§Ù‡ Ø²Ø¯Ù‡ Ø¨Ø´Ù‡
  document.addEventListener("keydown", e=>{
    if (e.code === "Escape" && document.fullscreenElement){
      overlay.style.display = "block";
      setTimeout(()=> overlay.style.display = "none", 2000);
      // ğŸš« Ø§ÛŒÙ†Ø¬Ø§ preventDefault Ù„Ø§Ø²Ù… Ù†ÛŒØ³Øª Ú†ÙˆÙ† ESC Ø¯ÛŒÚ¯Ù‡ fullscreen Ø±Ùˆ Ù†Ù…ÛŒâ€ŒØ¨Ù†Ø¯Ù‡
    }
  });
}

  start();
  enableFullscreen();
  </script>
  <script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/client/sw.js').then(()=>{
    console.log("âœ… Service Worker registered");
  });
}
</script>
</body>
</html>
