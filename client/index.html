<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebRTC Cloud Gaming Client</title>
  <style>
    body { background:#000; color:#0f0; font-family:monospace; text-align:center }
    canvas { max-width:90vw; max-height:80vh; display:block; margin:10px auto; background:#111; cursor:none }
    pre { white-space:pre-wrap; background:#111; color:#0f0; padding:8px; text-align:left; max-width:90vw; margin:10px auto }
  </style>
</head>
<body>
  <h1>🎮 Orbit Game Client</h1>
  <div id="statsBar" style="color:#0ff; margin:8px; font-weight:bold"></div>
  <canvas id="gameCanvas"></canvas>
  <audio id="remoteAudio" autoplay></audio>
  <pre id="log"></pre>

  <script>
  const logEl = document.getElementById('log');
  const log = (...args)=>{ const s=args.join(' '); console.log(s);  };

  let pc, channel, video;

  async function start(){
    pc = new RTCPeerConnection({
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    });

    pc.onicegatheringstatechange = ()=> log("gathering:", pc.iceGatheringState);
    pc.oniceconnectionstatechange = ()=> log("ice:", pc.iceConnectionState);
    pc.onconnectionstatechange = ()=> log("pc:", pc.connectionState);

   pc.addTransceiver("video", { direction:"recvonly" });
pc.addTransceiver("audio", { direction:"recvonly" });

    // منبع ویدیو (پنهان)
    video = document.createElement("video");
    video.autoplay = true;
    video.playsInline = true;
    video.muted = true; // لازم برای autoplay
    // مخفی بدون throttle
    video.style.position = "absolute";
    video.style.left = "-9999px";
    video.style.opacity = "0";
    video.style.width = "1px";
    video.style.height = "1px";
    video.style.pointerEvents = "none";
    document.body.appendChild(video);

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
		canvas.tabIndex = 0;       // مهم: بدون این، preventDefault برای Tab همیشه کار نمی‌کند
    canvas.focus();
pc.ontrack = (ev) => {
    log("ontrack:", ev.track.kind, "streams:", ev.streams.length);
    if (ev.track.kind === "video") {
        video.srcObject = ev.streams[0];
        video.play().catch(e => log("video.play err:", e));
        log("Video track received, width:", video.videoWidth, "height:", video.videoHeight);

        // 🎬 رسم با requestVideoFrameCallback (سینک دقیق با فریم‌ها)
        function pump(now, metadata) {
          if (video.videoWidth > 0) {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          }
          video.requestVideoFrameCallback(pump);
        }
        video.requestVideoFrameCallback(pump);;
    }
    if (ev.track.kind === "audio") {
        const audioEl = document.getElementById("remoteAudio");
        audioEl.srcObject = ev.streams[0];
    }
};
    // DataChannel برای ورودی
    channel = pc.createDataChannel("input");

    channel.onopen = ()=> {
      log("✅ DataChannel opened for input");
      enableInputEvents(canvas);
	   canvas.focus();   
    };
    channel.onclose = ()=> log("❌ DataChannel closed");
    // Offer → سرور
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    log("local offer set. SDP len:", offer.sdp.length);

    const res = await fetch('/offer', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({sdp: offer.sdp, type: offer.type})
    });
    const answer = await res.json();
    await pc.setRemoteDescription(answer);
    log("remote answer set. SDP len:", answer.sdp.length);



 // 📊 آمار
    let lastBytesReceived = 0, lastBytesSent = 0, lastTime = Date.now();
    let fpsNow = 0, kbpsDownNow = 0, kbpsUpNow = 0, rttNow = 0;

   setInterval(async ()=>{
      const now = Date.now();
      const stats = await pc.getStats();
      stats.forEach(report=>{
        if (report.type === "inbound-rtp" && report.kind === "video") {
          const deltaTime = (now - lastTime) / 1000;
          const deltaBytes = report.bytesReceived - lastBytesReceived;
          kbpsDownNow = (deltaBytes * 8 / 1000 / deltaTime).toFixed(1);
          fpsNow = report.framesPerSecond || 0;
          lastBytesReceived = report.bytesReceived;
        }
        if (report.type === "outbound-rtp") {
          const deltaTime = (now - lastTime) / 1000;
          const deltaBytes = report.bytesSent - lastBytesSent;
          kbpsUpNow = (deltaBytes * 8 / 1000 / deltaTime).toFixed(1);
          lastBytesSent = report.bytesSent;
        }
        if (report.type === "candidate-pair" && report.state === "succeeded" && report.currentRoundTripTime) {
          rttNow = (report.currentRoundTripTime * 1000).toFixed(1);
        }
      });
      lastTime = now;
      document.getElementById("statsBar").innerText =
        `FPS: ${fpsNow} | ⬇️ ${kbpsDownNow} kbps | ⬆️ ${kbpsUpNow} kbps | Ping: ${rttNow} ms`;
    }, 2000);
  }


  function enableInputEvents(canvas){
    // Pointer Lock روی canvas

    canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
    canvas.addEventListener("click", ()=>{
      canvas.requestPointerLock();
	   canvas.focus();
    });
    const blockDefaultKeys = new Set([
      "Tab","AltLeft","AltRight","MetaLeft","MetaRight",
      "F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12"
    ]);
    // کیبورد
    document.addEventListener("keydown", e=>{
	 if (blockDefaultKeys.has(e.code)) e.preventDefault();
      if(channel.readyState==="open")
        channel.send(JSON.stringify({type:"keydown", key:e.code}));
    });
    document.addEventListener("keyup", e=>{
	 if (blockDefaultKeys.has(e.code)) e.preventDefault();
      if(channel.readyState==="open")
        channel.send(JSON.stringify({type:"keyup", key:e.code}));
    });

    // موس (relative فقط وقتی lock فعاله)
    document.addEventListener("mousemove", e=>{
      if (document.pointerLockElement === canvas && channel.readyState==="open") {
        channel.send(JSON.stringify({type:"mousemove", x:e.movementX, y:e.movementY}));
      }
    });
    document.addEventListener("mousedown", e=>{
      if(channel.readyState==="open")
        channel.send(JSON.stringify({type:"mousedown", button:e.button}));
    });
    document.addEventListener("mouseup", e=>{
      if(channel.readyState==="open")
        channel.send(JSON.stringify({type:"mouseup", button:e.button}));
    });
    document.addEventListener("wheel", e=>{
      if(channel.readyState==="open")
        channel.send(JSON.stringify({type:"wheel", delta:e.deltaY}));
    });
	 window.addEventListener("blur", ()=> canvas.focus());
    document.addEventListener("visibilitychange", ()=>{
      if (document.visibilityState === "visible") canvas.focus();
    });
  }

  start();
  </script>
</body>
</html>
